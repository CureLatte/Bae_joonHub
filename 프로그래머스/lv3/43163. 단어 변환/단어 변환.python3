def next_words(target, words):
    new_word_list = []
    for word in words:
        cnt = 0
        for i in range(len(target)):
            if target[i] != word[i]:
                cnt += 1
        if cnt == 1:
            new_word_list.append(word)
    return new_word_list

def solution(begin, target, words):
    distance = []
    visited = []
    queue = [begin]
    temp_queue = []
    next_cnt = 1
    queue_check =[]
    cnt = 0
    graph_word = {}
    level = 0
    
    for word in words:
        graph_word[word] = next_words(word, words)
    graph_word[begin] = next_words(begin, words)
    
    if target not in words:
        return 0
    
    while len(queue) != 0:
        current_word = queue.pop(0)
        
        
        
        visited.append(current_word)
        next_list = graph_word[current_word]
        check = 0
        for next_word in next_list:
            if next_word not in visited and next_word not in queue_check:
                queue_check.append(next_word)
                temp_queue.append(next_word)
                check += 1
                
        if target in temp_queue:
            break
        
        if len(queue) == 0:
            level += 1
            queue = temp_queue
            temp_queue = []  
        
        
        
        if check != 0:
            cnt += 1

    print(level)
    return level +1